class Graph:



    def __init__(self, vertices):

        self.M = vertices   # Total number of vertices in the graph

        self.graph = []     # Array of edges



    # Add edges

    def add_edge(self, a, b, c):

        self.graph.append([a, b, c])



    # Print the solution

    def print_solution(self, distance,path):
        print("Vertex Distance from Source")

        for k in range(self.M):

            print("{0}\t\t{1}".format(k, distance[k]))
        print("Path")
        print(path)



    def bellman_ford(self, src):



        distance = [float("Inf")] * self.M

        distance[src] = 0
        path = []
        paths =[]
        h = []
        h_partial = [0 for x in range(self.M)]
        h_partial[src] +=1
        h.append([x for x in h_partial])    
        p_partial = [-1 for x in range(self.M)]
        p =[]
        p.append([x for x in p_partial])
        tables = []
        tables.append([x for x in distance])
        # print(distance)
        path.append(src)
        paths.append([x for x in path])



        for _ in range(self.M - 1):

            for a, b, c in self.graph:

                if distance[a] != float("Inf") and distance[a] + c < distance[b]:
                    
                    distance[b] = distance[a] + c
                    if b in path:
                        path.remove(b)
                    path.append(b)
                    p_partial[b] = a
                    h_partial[b]+=1
                    h.append([x for x in h_partial])  
                    p.append([x for x in p_partial])
                    paths.append([x for x in path])
                    tables.append([x for x in distance])
                # print(distance)



        for a, b, c in self.graph:

            if distance[a] != float("Inf") and distance[a] + c < distance[b]:

                print("Graph contains negative weight cycle")

                return
        # print("R")
        # print(paths)
        # print("d")
        # print(tables)
        # print("p")
        # print(p)
        # print("h")
        # print(h)
        return (tables,paths,p,h)

        self.print_solution(distance,path)



g = Graph(7)

g.add_edge(5, 4, -5)
g.add_edge(5, 6, -4)
g.add_edge(5, 3, -10)

g.add_edge(6, 4, -1)
g.add_edge(6, 1, -5)

g.add_edge(1, 2, -2)

g.add_edge(3, 4, 7)
g.add_edge(3, 2, -3)
g.add_edge(3, 1, 4)

g.add_edge(4, 1, -2)


# g.add_edge(0, 1, 2)

# g.add_edge(0, 2, 4)

# g.add_edge(1, 3, 2)

# g.add_edge(2, 4, 3)

# g.add_edge(2, 3, 4)

# g.add_edge(4, 3, -5)



d,r,p,h = g.bellman_ford(5)

stringOut=''
print("a")
print(d)
for i in range(len(d)):
    stringOut+="$ R = {"
    stringOut+="".join(map(str,[str(x)+"," for x in r[i]]))
    stringOut+="} r = "
    stringOut+="".join(map(str, r[i][:1]))
    stringOut+="$ \n"
    stringOut+=""" 
    \\begin{tabular}{|c|l|}
    \hline
    \multirow{7}{*}{d} &          \\ \cline{2-2} 
                       & p\_1 ="""+ str(d[i][1])+ """\\\\ \cline{2-2} 
                       & p\_2 ="""+ str(d[i][2])+ """\\\\ \cline{2-2} 
                       & p\_3 ="""+ str(d[i][3])+ """\\\\ \cline{2-2} 
                       & p\_4 ="""+ str(d[i][4])+ """\\\\ \cline{2-2} 
                       & p\_5 ="""+ str(d[i][5])+ """\\\\ \cline{2-2} 
                       & p\_6 ="""+ str(d[i][6])+ """\\\\ \hline
    \end{tabular}
    """
    stringOut+=""" 
    \\begin{tabular}{|c|l|}
    \hline
    \multirow{7}{*}{h} &          \\ \cline{2-2} 
                       & p\_1 ="""+ str(h[i][1])+ """\\\\ \cline{2-2} 
                       & p\_2 ="""+ str(h[i][2])+ """\\\\ \cline{2-2} 
                       & p\_3 ="""+ str(h[i][3])+ """\\\\ \cline{2-2} 
                       & p\_4 ="""+ str(h[i][4])+ """\\\\ \cline{2-2} 
                       & p\_5 ="""+ str(h[i][5])+ """\\\\ \cline{2-2} 
                       & p\_6 ="""+ str(h[i][6])+ """\\\\ \hline
    \end{tabular}

    """
    
    
    # stringOut+=
print(stringOut)
f = open("resolucao2.txt","w")
f.write(stringOut)
f.close()

# $ R = {5} Q = {1,2,3,4} r = 5$ 


    # \begin{tabular}{|c|l|}
    # \hline
    # \multirow{7}{*}{d} &          \\ \cline{2-2} 
    #                    & p\_1 = ? \\ \cline{2-2} 
    #                    & p\_2 = ? \\ \cline{2-2} 
    #                    & p\_3 = ? \\ \cline{2-2} 
    #                    & p\_4 = ? \\ \cline{2-2} 
    #                    & p\_5 = ? \\ \cline{2-2} 
    #                    & p\_6 = ? \\ \hline
    # \end{tabular}


# positive_infinity = float('inf')
# print('Positive Infinity: ', positive_infinity)
